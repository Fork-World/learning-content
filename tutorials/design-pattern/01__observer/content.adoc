= Constructor Value versus Observer Pattern in Vaadin

:type: text
:tags: Flow, Design Pattern, Java, Observer
:description: Learn how to use the Observer Pattern for decoupling Vaadin Components
:repo: https://github.com/vaadin-learning-center/flow-design-pattern-observer
:linkattrs:
:imagesdir: ./images

In this tutorial, we will see how to use the observer design pattern to decouple Vaadin components.

== Who belongs to whom?

It is quite common to connect two components using constructor parameters.
This procedure can be seen very clearly, for example, in the construction of graphic surfaces.
Take, for example, the following pseudo source code.

[source,java]
----
public class SubView {
  private MainView mainView;
  public SubView(MainView mainView) {
    this.mainView = mainView;
  }
  public void buttonClicked(String input) {
    mainView.setInputValue(input);
  }
}
----

This subcomponent gets the surrounding main component via the constructor.
The instance of this given component is just needed for a value transit.
The value is the result of a user interaction inside the subcomponent and consumed inside the surrounding element.
This procedure leads to results in various challenges that I find avoidable.
First, this sub-component is hard-bound to the main element.
This hard coupled type makes no sense since this bond is based purely on the use of the generated values.
Furthermore, the testing of the sub-component is more difficult because an instance of the main component or a corresponding MOCK must be used.
Again, this is an additional requirement that merely adds complexity and at the same time, reduces the abstraction of the individual components.
So what can you do here and add that to the project without another framework as a dependency?

== Observer - The classic

There is a straightforward design pattern that can help here. We're talking about the Observer pattern.

[source,java]
----
public class Observable<KEY, VALUE> {
  private final Map<KEY, Consumer<VALUE>> listeners = new ConcurrentHashMap<>();
  public void register(KEY key, Consumer<VALUE> listener) {
    listeners.put(key, listener);
  }
  public void unregister(KEY key) {
    listeners.remove(key);
  }
  public void sentEvent(VALUE event) {
    listeners.values()
             .forEach(listener -> listener.accept(event));
  }
}
----

The basic principle consists of three interactions.
In a map, a consumer is stored for a given key.
The consumer is the utilization unit for an event or better an input type that is defined by the second type definition of the map.
You can register with a key and later the associated consumer can also be removed again from this map if needed.
If a data package is now ready for processing, it will be sent to all consumers who have already registered at this time using the method for posting events.
In practice, all existing consumers in the map are processing the value once in an undefined order.
The sent event must be immutable itself.

== Registry

To simplify the process of registering and unsubscribing, you can modify the Observer design pattern a bit.

[source,java]
----
public interface Registration {
  void remove();
}
----

[source,java]
----
public class Registry<KEY, VALUE> {
  private final Map<KEY, Consumer<VALUE>> listeners = new ConcurrentHashMap<>();
  public static <K, V> Registry<K, V> instance() {
    return new Registry<>();
  }
  public Registration register(KEY key, Consumer<VALUE> listener) {
    listeners.put(key, listener);
    return () -> listeners.remove(key);
  }
  public void sentEvent(VALUE event) {
    listeners.values()
             .forEach(listener -> listener.accept(event));
  }
}
----

For this, a Functional Interface with the name **Registration** is defined, which only provides the method to remove itself from the registry.
This method implements the respective logout process.
The instance of a **Registration** is the return value of a registration process itself.
The processing of the event data is made in the same way we have done it at the implementation of the Observable.
The practical use is shown below in a JUnit5 test.

[source,java]
----
final Registry<String, Event> eventBus = Registry.instance();

final String expected = "message 001";

final AtomicInteger counter = new AtomicInteger(0);
final String        key01   = "Consumer-01";
final String        key02   = "Consumer-02";

final Registration register01 = eventBus.register(key01, (event) -> {
  assertEquals(expected, event.getMessage());
  counter.incrementAndGet();
});
final Registration register02 = eventBus.register(key02, (event) -> {
  assertEquals(expected, event.getMessage());
  counter.incrementAndGet();
});

eventBus.sentEvent(new Event(expected, ""));
Assertions.assertEquals(2, counter.get());

register01.remove();
eventBus.sentEvent(new Event(expected, ""));
Assertions.assertEquals(3, counter.get());
----

== Coupling of components 

Let's start with the sub-component.
This element is no longer linked to the main component.
In this example, I am using a general static event bus of type **Registry**.
Of course, you can also use your event bus instance per component, which further decouples the component.

[source,java]
----
public class SubView {
  public void buttonClicked(String input) {
    EVENT_BUS.sentEvent(new Event(input));
  }
  public Registration register(String key, Consumer<Event> listener) {
    return EVENT_BUS.register(key, listener);
  }
}
----

If another component wants to use the values of the fictitious user interaction, it can register with the instance of the sub-component.

[source,java]
----
public class MainView {
  //for demo public
  public  SubView      subView      = new SubView();
  private Registration registration = subView.register("keyXYZ", 
                                                       e -> inputValue = e.getValue());
  private String       inputValue;

  public String getInputValue() {
    return inputValue;
  }

  public void release() {
    registration.remove();
  }
}
----

The corresponding jUnit5 test looks like this.

[source,java]
----
final MainView mainView = new MainView();
final String inputValue = "inputValue";
//subview is public for demo
mainView.subView.buttonClicked(inputValue);

Assertions.assertEquals(inputValue, mainView.getInputValue());
----

== How to use this with Vaadin?
If we are using Vaadin, the Interface **Registration** is already existing.
And we can even improve the given implementation of the class of type **Registry** .
So far we needed a **key** for registration, but this is not necessary.
Switching the internal data structure from a **Map** to a **Set** , we can use the consumer for the registration and de-registration.

[source, java]
----
public class Registry<VALUE> {

  private final Set<Consumer<VALUE>> listeners = ConcurrentHashMap.newKeySet();

  public Registration register(Consumer<VALUE> listener) {
    listeners.add(listener);
    return () -> listeners.remove(listener);
  }

  public void sentEvent(VALUE event) {
    listeners.forEach(listener -> listener.accept(event));
  }
}
----

If we want to build a component-specific **Registry** to get more type-safety,
we have to extend the generic class and adding the event-type itself.

[source, java]
----
public class DemoComponentRegistry
    extends Registry<DemoComponentRegistry.ValueEvent> {

  public static class ValueEvent
      extends Pair<String, String> {

    public ValueEvent(String id, String value) {
      super(id, value);
    }

    public String id() {
      return getT1();
    }

    public String value() {
      return getT2();
    }
  }
}
----

To demonstrate the usage of this class of type **DemoComponentRegistry** a class with the name **DemoComponent** is created.
The component contains a few attributes to receive and sent events. The basic idea is the following:
This component can send a message with the content provided by the user.
In technical words, the input value from the instance of type **TextField** will be wrapped into an instance of an event and sent to the registry
while the user pressed the button. Additionally, the component can present the event data that is received from the registry.
The id, as well as the value itself from the event, is shown in the two text fields that have the prefix **event** at their name.
[source, java]
----
public class DemoComponent
    extends Composite<FormLayout>
    implements HasLogger {

  private final Checkbox  active       = new Checkbox(false);
  private final TextField input        = new TextField();
  private final Button    sendBtn      = new Button();
  private final TextField eventID      = new TextField("ID:");
  private final TextField eventMessage = new TextField("MSG:");

  private Result<Registration> registrationResult = Result.failure("not registered");

  //SNIP code here
}
----

The implementation to sent an event is shown below.
Inside the **ClickListener** the instance of type **ValueEvent** is created and filled with the component id itself
together with the value from the input field.
Afterwards, the freshly created event will be sent to all components that are interested in this information.

[source, java]
----
    sendBtn.setText("send event");
    sendBtn.addClickListener(e -> {
      final String value = input.getValue();
      final String id = DemoComponent.this.getId()
                                          .orElse("");
      final ValueEvent valueEvent = new ValueEvent(id, value);

      fireCustomEvent(valueEvent);
    });
----

[source, java]
----
  private void fireCustomEvent(ValueEvent valueEvent) {
    UI.getCurrent()
      .getSession()
      .getAttribute(DemoComponentRegistry.class)
      .sentEvent(valueEvent);
  }
----

The instance of the registry itself is stored inside the **VaadinSession**.
With this approach, every user will have its instance of an event-bus.
If events should be shared between users, use a JVM static instance.

The missing piece is now the registration at the event-bus itself. To make it even a bit more dynamic,
the checkbox (named **active**) is used to register and de-register the component itself.

[source, java]
----
    active.setLabel("receiving events");
    active.addValueChangeListener(e -> {
      final Boolean isActive = e.getValue();
      if (isActive) registrationResult = Result.ofNullable(registerForEvents());
      else {
        registrationResult.ifPresent(Registration::remove);
        registrationResult = Result.failure("not registered");
        eventID.setValue("");
        eventMessage.setValue("");
      }
    });

----

[source, java]
----
  private Registration registerForEvents() {
    return UI.getCurrent()
             .getSession()
             .getAttribute(DemoComponentRegistry.class)
             .register(valueEvent -> {
               if (nonNull(valueEvent.id()) && !valueEvent.id()
                                                          .equals(getId().orElse(""))) {
                 eventID.setValue(valueEvent.id());
                 eventMessage.setValue(valueEvent.value());
               }
             });
  }
----

In the same way, you saw it before, the main view is created and holds a few instances of type **DemoComponent** additionally.
Everything together looks like the following.

image::01_main-view-empty.jpg[]

If you want to see this in action you could have a view at this video on https://youtu.be/jVCwFi461TQ[youtube]
or you can try it by yourself on  https://flow-design-pattern-observer.herokuapp.com/[heroku]


== Conclusion

With a few lines of source code, we have not only decoupled the components much better from each other but also simplified the testing of the individual elements.
There are no mocks needed anymore.
The increased abstraction also allows more than one component to register on the sub-component shown here.
Of course, one should not forget at this point that the logoff from a registry should not be forgotten to allow the garbage collector to function correctly.

Happy Coding