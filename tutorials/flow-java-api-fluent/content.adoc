= Fluent Component API For Flow

:type: text, video
:tags: Layout, Flow, API, Java, Fluent API
:description: How to create a fluent API for Flow
:repo: https://github.com/vaadin-learning-center/flow-api-fluent
:linkattrs:
:imagesdir: ./images

In this tutorial, we explore possibilities how to create a fluent API
for Vaadin Flow.

== Download base project
As "Hello World" basic project the `flow-helloworld-maven-meecrowave`
from the learning centre is used.
You can find the latest version
here: https://github.com/vaadin-learning-center/flow-helloworld-maven-meecrowave[https://github.com/vaadin-learning-center/flow-helloworld-maven-meecrowave]

== The basic ideas behind

If you are using Vaadin, mostly your code looks like the following.
Let´s assume you want to create a `PasswordField`.
For this, you often start with the instantiation of the class.

=== The recommended Vaadin way

However, first, we are doing it in the original Vaadin way.
The PasswordField created as an attribute
alternatively, as a field inside the initialisation block, mostly the constructor.

[source,java]
----
    final PasswordField password = new PasswordField();
    password.setPlaceholder("password");
    password.setId("pf-password-id");
    password.setValueChangeMode(ValueChangeMode.EAGER);
    password.setVisible(true);
    password.setRequired(true);
----

If it is only like this, it looks ok so far. However, if the attribute is in a more global context, let´s say as a class attribute,
you have to maintain at least two places. First, the place where
the attribute is defined and second the place where you are initialising the attribute itself.

[source,java]
----
    final PasswordField password = new PasswordField();

    public MyClass(){
      password.setPlaceholder("password");
      password.setId("pf-password-id");
      password.setValueChangeMode(ValueChangeMode.EAGER);
      password.setVisible(true);
      password.setRequired(true);      
    }
----

=== inner non static blocks

If you want to hold the definition of the attribute and
the initialising near together, you could think about using
inner nonstatic blocks. At the first view, it looks
nice. Both things are near together. Would this
solution be refactoring safe? Well, if inner non-static
blocks are used, the developer must know at what time
each block and the constructor is called.
Order matters here and the IDE is mostly not able to support you
during refactorings.

[source,java]
----
    final PasswordField password = new PasswordField();

    {
      password.setPlaceholder("password");
      password.setId("pf-password-id");
      password.setValueChangeMode(ValueChangeMode.EAGER);
      password.setVisible(true);
      password.setRequired(true);      
    }
----

=== Anonymous Inner Class

One other way is the usage of the *double curly braces* pattern.
If you are searching for more information's about this
you are finding many descriptions that this is an anti-pattern.
Have in mind that most posts are from the year 2014/2015.
The main points are,
1. that a lot of anonymous classes are created
2. a reference is held between holding class and anonymous class

Both arguments are not as bad as it looks.
Other languages like Kotlin and Scala are creating many
classes, and the even the implementation of an ActionListener
is mostly an anonymous class as well. So this is something,
the GC can handle quite well. To get a few information's about it,
use the following flags and enjoy reading the GC Logs. 

* *-XX:-TraceClassLoading* Trace loading of classes.
* *-XX:-TraceClassLoadingPreorder* Trace all classes loaded in order referenced (not loaded).
* *-XX:-TraceClassResolution* Trace constant pool resolutions.
* *-XX:-TraceClassUnloading* Trace unloading of classes.
* *-XX:-TraceLoaderConstraints* Trace recording of loader constraints.

The little bit more biting fact is the reference itself.
As long as you are not sharing references across the application,
this is never a more significant challenge for the GC. So, have in mind.
Don´t share the references, hold them inside your _View_.

If you are using this, your code looks like the following.

[source,java]
----
    final PasswordField password = new PasswordField() {{
      setPlaceholder("password");
      setId("pf-password-id");
      setValueChangeMode(ValueChangeMode.EAGER);
      setVisible(true);
      setRequired(true);      
    }}
----

Now, the creation of the instance and the initialising is near together.
The IDE can support you as well. Maybe this is not what you want to do.
What could be the next solution?

=== Optional or something similar

Since Java8 we have the class Optional, and we could use this
to hold the definition and the initialising near together.
You can somehow use the method *ifPresent*.
This usage of the Optional would not create anonymous classes and no reference you should have an eye on.

[source,java]
----
    final PasswordField password = Optional.of(new PasswordField())
     .map( pf -> {
             pf.setPlaceholder("password");
             pf.setId("pf-password-id");
             pf.setValueChangeMode(ValueChangeMode.EAGER);
             pf.setVisible(true);
             pf.setRequired(true);
     })
     .get();
----

== Fluent API

Finally, we are at the point to have a view on the
Fluent API for Vaadin. There are at least two different ways you can add
the fluent API into the Vaadin Components.
The oo-style would be the way to extend the Components itself.
This construction would lead to a parallel Class - hierarchy. For sure, you can downcast
every time to the original class, but the main thing is:
The fluent API is part of the component itself.

My point of view is different. I don´t want to have this
as part of the component itself. Moreover, I don´t want to
create a parallel class hierarchy. I prefer a solution that
can be used in new and in old projects at the same time.
Also, I don´t want to force the developer every time to use this.

One big thing is, how you can deal with the existing code.
If there is an existing component, and I want to invoke a few methods,
I can not or don´t want to create a new instance.
The fluent API should be usable for pre-initialized objects as well.

=== The generic way

First, we have a look at the generic version of the fluent API.
To do so is important because this is the fall back if the fluent API is missing a method
alternatively, you want to use the fluent API for your self-written components without
writing a corresponding fluent API.

The Vaadin platform itself brings a few nice things, that we can use.
For example, the data binding is using a Functional Interface called
`Setter&lt;T, V&gt;`. 

[source,java]
----
@FunctionalInterface
public interface Setter<BEAN, FIELDVALUE> extends BiConsumer<BEAN, FIELDVALUE>, Serializable {
  void accept(BEAN var1, FIELDVALUE var2);
}
----

With this, the attribute can set with a value.
The usage looks like th following.

[source,java]
----
Setter<PasswordField, String> setter = new Setter<PasswordField, String>() {
  @Override
  public void accept(PasswordField passwordField, String value) {
    passwordField.setId(value);
  }
};
setter.accept(password, "id" );
----


This code we can refactor to some more compact code, now.
First, we are transforming the anonymous inner class into a Lambda construct.

[source,java]
----
Setter<PasswordField, String> setter 
    = (Setter<PasswordField, String>) (passwordField, value) -> passwordField.setId(value);
setter.accept(password, "id" );
----

We can remove the Type - declaration and using more generic names for the parameters.

[source,java]
----
Setter&lt;PasswordField, String&gt; setter
 = (bean, value) -&gt; bean.setId(value);
 setter.accept(password, "id" );
----

Now we can convert the Lambda construct into the usage of a method reference.

[source,java]
----
    Setter<PasswordField, String> setter 
        = Component::setId;
    setter.accept(password, "id" );
----

The code is quite compact now. The next step is the abstraction of the
definition what to do from the usage itself.
The definition, what to do, we can write as a function. For this we
define an interface called `ComponentMixin&lt;T extends Component&gt;`.
The instance of the component itself is held inside an Optional.
However, we are not defining an attribute, and we are only defining the way how to get it.
Now we can declare the generic way, how to set an attribute plus the return value,
the instance itself.

[source,java]
----
public interface ComponentMixin<T extends Component> {

  Optional<T> component();

  default <V> ComponentMixin<T> set(Setter<T, V> target, V value) {
    component().ifPresent(c -> target.accept(c, value));
    return this;
  }
}
----

On the other side, we need the place to hold the instance of the component itself.
This is done inside the class called `ComponentHolder&lt;T extends Component&gt;`

[source,java]
----
public class ComponentHolder<T extends Component> {

  private Optional<T> component;

  public ComponentHolder(Optional<T> component) {
    this.component = component;
  }

  public ComponentHolder(Supplier<T> supplier) {
    this.component = ofNullable(supplier.get());
  }

  public Optional<T> component() {
    return component;
  }
}
----

With this way to write the code, we have now divided the stateful and the stateless part.
Both together is called `ComponentBuilder`.

[source,java]
----
public class ComponentBuilder
    extends ComponentHolder<Component>
    implements ComponentMixin {

  public ComponentBuilder(Optional<Component> component) {
    super(component);
  }

  public ComponentBuilder(Supplier<Component> supplier) {
    super(supplier);
  }
}
----

Now it is time to create the basic UI to show how we can use a
generic ComponentBuilder. The example shows how to create an instance of a
PasswordField. 

[source,java]
----
  private final PasswordField password = (PasswordField) new ComponentBuilder(PasswordField::new)
      .setId("pf-password-id")
      .set((Setter<PasswordField, String>) PasswordField::setPlaceholder, "password")
      .build();
----

As you could see clearly, this is not nice because we have to put too much
type information´s into the code itself. For this there are
individual Builder provided, like the `PasswordFieldBuilder`.

[source,java]
----
  private final PasswordField password = new PasswordFieldBuilder(PasswordField::new)
      .setId("pf-password-id")
      .setPlaceholder("password")
      .build();
----

If you have an instance already, you can use this one as well.
Working with typed composites is giving  you an already created instance of
the type of class that is used inside the declaration.
The demo app ist using a `Composite&lt;HorizontalLayout&gt;` as base.
The method *getContent()* will give you precisely this instance.
To configure the instance, use this on as input for the Builder.

[source,java]
----
  public LoginView() {
    new HorizontalLayoutBuilder(ofNullable(getContent()))
        .setDefaultVerticalComponentAlignment(Alignment.CENTER)
        .setJustifyContentMode(FlexComponent.JustifyContentMode.CENTER)
        .setSizeFull()
        .component()
        .ifPresent(l -> l.add(layout));
  }
----